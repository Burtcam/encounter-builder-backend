// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package writeMonsters

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const insertFocusSpellsCasts = `-- name: InsertFocusSpellsCasts :batchexec
INSERT INTO focus_spell_casting_spells (focus_spell_casting_id, spell_id)
VALUES ($1, $2)
`

type InsertFocusSpellsCastsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertFocusSpellsCastsParams struct {
	FocusSpellCastingID pgtype.Int4
	SpellID             pgtype.Text
}

func (q *Queries) InsertFocusSpellsCasts(ctx context.Context, arg []InsertFocusSpellsCastsParams) *InsertFocusSpellsCastsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.FocusSpellCastingID,
			a.SpellID,
		}
		batch.Queue(insertFocusSpellsCasts, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertFocusSpellsCastsBatchResults{br, len(arg), false}
}

func (b *InsertFocusSpellsCastsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertFocusSpellsCastsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertInnateSpellUse = `-- name: InsertInnateSpellUse :batchexec
INSERT INTO innate_spell_uses (innate_spell_casting_id, spell_id, level, uses)
VALUES ($1, $2, $3, $4)
`

type InsertInnateSpellUseBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertInnateSpellUseParams struct {
	InnateSpellCastingID pgtype.Int4
	SpellID              pgtype.Text
	Level                pgtype.Int4
	Uses                 pgtype.Text
}

func (q *Queries) InsertInnateSpellUse(ctx context.Context, arg []InsertInnateSpellUseParams) *InsertInnateSpellUseBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.InnateSpellCastingID,
			a.SpellID,
			a.Level,
			a.Uses,
		}
		batch.Queue(insertInnateSpellUse, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertInnateSpellUseBatchResults{br, len(arg), false}
}

func (b *InsertInnateSpellUseBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertInnateSpellUseBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertItemTraits = `-- name: InsertItemTraits :batchexec
INSERT INTO item_traits (item_id, trait)
VALUES ($1, $2)
`

type InsertItemTraitsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertItemTraitsParams struct {
	ItemID pgtype.Text
	Trait  pgtype.Text
}

func (q *Queries) InsertItemTraits(ctx context.Context, arg []InsertItemTraitsParams) *InsertItemTraitsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ItemID,
			a.Trait,
		}
		batch.Queue(insertItemTraits, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertItemTraitsBatchResults{br, len(arg), false}
}

func (b *InsertItemTraitsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertItemTraitsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertMonsterImmunities = `-- name: InsertMonsterImmunities :batchexec
INSERT INTO monster_immunities (monster_id, immunity)
VALUES ($1, $2)
`

type InsertMonsterImmunitiesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertMonsterImmunitiesParams struct {
	MonsterID pgtype.Int4
	Immunity  pgtype.Text
}

func (q *Queries) InsertMonsterImmunities(ctx context.Context, arg []InsertMonsterImmunitiesParams) *InsertMonsterImmunitiesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.MonsterID,
			a.Immunity,
		}
		batch.Queue(insertMonsterImmunities, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertMonsterImmunitiesBatchResults{br, len(arg), false}
}

func (b *InsertMonsterImmunitiesBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertMonsterImmunitiesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertPreparedSlots = `-- name: InsertPreparedSlots :batchexec
INSERT INTO prepared_slots (prepared_spell_casting_id, level, spell_id)
VALUES ($1, $2, $3)
`

type InsertPreparedSlotsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertPreparedSlotsParams struct {
	PreparedSpellCastingID pgtype.Int4
	Level                  pgtype.Text
	SpellID                pgtype.Text
}

func (q *Queries) InsertPreparedSlots(ctx context.Context, arg []InsertPreparedSlotsParams) *InsertPreparedSlotsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.PreparedSpellCastingID,
			a.Level,
			a.SpellID,
		}
		batch.Queue(insertPreparedSlots, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertPreparedSlotsBatchResults{br, len(arg), false}
}

func (b *InsertPreparedSlotsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertPreparedSlotsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertSpellTraits = `-- name: InsertSpellTraits :batchexec
INSERT INTO spell_traits (spell_id, trait)
VALUES ($1, $2)
`

type InsertSpellTraitsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertSpellTraitsParams struct {
	SpellID pgtype.Text
	Trait   pgtype.Text
}

func (q *Queries) InsertSpellTraits(ctx context.Context, arg []InsertSpellTraitsParams) *InsertSpellTraitsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.SpellID,
			a.Trait,
		}
		batch.Queue(insertSpellTraits, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertSpellTraitsBatchResults{br, len(arg), false}
}

func (b *InsertSpellTraitsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertSpellTraitsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertSpontaneousSpellList = `-- name: InsertSpontaneousSpellList :batchexec
INSERT INTO spontaneous_spell_list (spontaneous_spell_casting_id, spell_id)
VALUES ($1, $2)
`

type InsertSpontaneousSpellListBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertSpontaneousSpellListParams struct {
	SpontaneousSpellCastingID pgtype.Int4
	SpellID                   pgtype.Text
}

func (q *Queries) InsertSpontaneousSpellList(ctx context.Context, arg []InsertSpontaneousSpellListParams) *InsertSpontaneousSpellListBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.SpontaneousSpellCastingID,
			a.SpellID,
		}
		batch.Queue(insertSpontaneousSpellList, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertSpontaneousSpellListBatchResults{br, len(arg), false}
}

func (b *InsertSpontaneousSpellListBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertSpontaneousSpellListBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertSpontaneousSpellSlots = `-- name: InsertSpontaneousSpellSlots :batchexec
INSERT INTO spontaneous_slots (spontaneous_spell_casting_id, level, casts)
VALUES ($1, $2, $3)
`

type InsertSpontaneousSpellSlotsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertSpontaneousSpellSlotsParams struct {
	SpontaneousSpellCastingID pgtype.Int4
	Level                     pgtype.Text
	Casts                     pgtype.Text
}

func (q *Queries) InsertSpontaneousSpellSlots(ctx context.Context, arg []InsertSpontaneousSpellSlotsParams) *InsertSpontaneousSpellSlotsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.SpontaneousSpellCastingID,
			a.Level,
			a.Casts,
		}
		batch.Queue(insertSpontaneousSpellSlots, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertSpontaneousSpellSlotsBatchResults{br, len(arg), false}
}

func (b *InsertSpontaneousSpellSlotsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertSpontaneousSpellSlotsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
